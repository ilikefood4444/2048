#include <SFML/Graphics.hpp> 
#include <vector>
#include <ctime>
#include <cstdlib>

// Constants
const int windowWidth = 800;
const int windowHeight = 600;
const float gravity = 0.5f;
const float lift = -15.0f;
const float pipeSpeed = 3.0f;
const int gap = 200;
const int pipeWidth = 80;
const float birdRadius = 20.0f;

// Function to generate random pipe heights
int randomHeight() {
    return rand() % (windowHeight - gap);
}

class Pipe {
public:
    sf::RectangleShape topPipe;
    sf::RectangleShape bottomPipe;
    float posX;

    Pipe(float x) {
        posX = x;
        float pipeHeight = randomHeight();
        topPipe.setSize(sf::Vector2f(pipeWidth, pipeHeight));
        bottomPipe.setSize(sf::Vector2f(pipeWidth, windowHeight - pipeHeight - gap));
        topPipe.setPosition(posX, 0);
        bottomPipe.setPosition(posX, pipeHeight + gap);
    }

    void update() {
        posX -= pipeSpeed;
        topPipe.setPosition(posX, 0);
        bottomPipe.setPosition(posX, topPipe.getSize().y + gap);
    }

    bool isOffScreen() {
        return posX < -pipeWidth;
    }
};

class Bird {
public:
    sf::CircleShape shape;
    float velocity;

    Bird(float x, float y) {
        shape.setRadius(birdRadius);
        shape.setPosition(x, y);
        velocity = 0;
    }

    void update() {
        velocity += gravity;
        shape.move(0, velocity);
    }

    void flap() {
        velocity = lift;
    }
};

int main() {
    // Create the main window
    sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), "Flappy Bird");
    srand(static_cast<unsigned>(time(0)));

    Bird bird(windowWidth / 4, windowHeight / 2);
    std::vector<Pipe> pipes;
    pipes.push_back(Pipe(windowWidth));

    sf::Clock clock;
    float spawnTimer = 0;
    bool isGameOver = false;

    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();
            if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Space && !isGameOver)
                bird.flap();
        }

        if (!isGameOver) {
            float dt = clock.restart().asSeconds();
            spawnTimer += dt;

            if (spawnTimer > 2.0f) {
                pipes.push_back(Pipe(windowWidth));
                spawnTimer = 0;
            }

            bird.update();

            for (auto &pipe : pipes)
                pipe.update();

            if (pipes.size() > 0 && pipes.front().isOffScreen())
                pipes.erase(pipes.begin());

            for (auto &pipe : pipes) {
                if (bird.shape.getGlobalBounds().intersects(pipe.topPipe.getGlobalBounds()) || 
                    bird.shape.getGlobalBounds().intersects(pipe.bottomPipe.getGlobalBounds())) {
                    isGameOver = true;
                }
            }

            if (bird.shape.getPosition().y > windowHeight || bird.shape.getPosition().y < 0) {
                isGameOver = true;
            }
        }

        // Clear screen
        window.clear();

        // Draw the bird
        window.draw(bird.shape);

        // Draw pipes
        for (auto &pipe : pipes) {
            window.draw(pipe.topPipe);
            window.draw(pipe.bottomPipe);
        }

        // Update the window
        window.display();
    }

    return 0;
}
